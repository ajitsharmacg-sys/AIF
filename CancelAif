<div
  class="ms-auto d-flex align-items-center gap-2"
  v-if="
    !['DRAFT', 'INVALID'].includes(aif_status) &&
    (
      user_role.includes(SALES_OPS_USER) ||
      (ADMIN_ROLE || []).some(role => user_role.includes(role))
    )
  "
>


<div
  class="ms-auto d-flex align-items-center gap-2"
  v-if="
    !['DRAFT', 'INVALID'].includes(aif_status) &&
    (
      ADMIN_ROLE.some(r => user_role.includes(r)) ||
      AIF_STATUS_TO_ROLE[aif_status]
        ?.some(r => user_role.includes(r))
    )
  "
>

<div
  class="form-check"
  v-if="
    aif_status === 'PLANNED' &&
    get_line_status(line)?.status === 'AWAITING_APPROVAL' &&
    LINE_STATUS_TO_ROLE['AWAITING_APPROVAL']
      .some(role => user_role.includes(role))
  "
>

sleep(ms = 0) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
async export_to_excel(aif) {
  this.isLoading = true;
  this.downloadStep = "Preparing‚Ä¶";

  await this.sleep(); // üëà allow UI paint

  const hasCustomers = (aif.aif_customer_lines || []).length > 0;

  this.downloadStep = "Generating Header file‚Ä¶";
  await this.sleep(); // üëà allow UI paint
  await this.generateWebEDIHeaderFile(aif);

  if (hasCustomers) {
    this.downloadStep = "Generating Line file‚Ä¶";
    await this.sleep(); // üëà allow UI paint
    await this.generateWebEDILineFile(aif);
  }

  this.downloadStep = "Finalizing‚Ä¶";
  await this.sleep(); // üëà allow UI paint

  this.isLoading = false;
  this.downloadStep = "";
}

async generateWebEDIHeaderFile(aif) {
  this.ws_data = [];
  this.ws_data.push(this.webedi_header);

  const cancelledIds = (aif.aif_cancel_numbers || "")
    .split(";")
    .map(v => v.trim())
    .filter(Boolean);

  // ===============================
  // 1Ô∏è‚É£ CANCELLED AIFs ‚Üí UPDATE + INSERT
  // ===============================
  if (cancelledIds.length > 0) {
    const cancelledAifs = await this.load_aifs_for_cancellation(cancelledIds);

    for (const cancelledAif of cancelledAifs) {

      // üîÅ UPDATE cancelled AIF
      await this.buildWebEDIHeaderRows({
        sourceAIF: cancelledAif,
        effectiveAIF: aif,
        trxType: "UPDATE"
      });

      // ‚ûï INSERT cancelled AIF
      await this.buildWebEDIHeaderRows({
        sourceAIF: cancelledAif,
        effectiveAIF: aif,
        trxType: "INSERT"
      });
    }
  }

  // ===============================
  // 2Ô∏è‚É£ CURRENT AIF ‚Üí NEW INSERT
  // ===============================
  await this.buildWebEDIHeaderRows({
    sourceAIF: aif,
    effectiveAIF: aif,
    trxType: "INSERT"
  });

  const wb = utils.book_new();
  const ws = utils.aoa_to_sheet(this.ws_data);
  utils.book_append_sheet(wb, ws, "Header");

  writeFile(
    wb,
    `WebADI_AIF_${aif.aif_id}_Header_Set_${this.getCurrentDateTimeForFile()}.xlsx`
  );
}


<div
    class="ms-auto d-flex align-items-center gap-2"
    v-if="!['DRAFT', 'INVALID'].includes(this.aif_status) 
        && this.user_role.includes('AIF App Sales Ops User')"
>
    <span class="text-muted small fw-medium">
        Download Web ADI Template
    </span>

    <button
        type="button"
        class="btn btn-sm btn-outline-primary d-flex align-items-center gap-2"
        @click="export_to_excel(selected_aif)"
        :disabled="isLoading"
    >
        <template v-if="!isLoading">
            <i class="bi bi-download"></i>
        </template>

        <template v-else>
            <span class="spinner-border spinner-border-sm" role="status"></span>
            <span class="small">[[ downloadStep ]]</span>
        </template>
    </button>
</div>

<button
    type="button"
    class="btn btn-sm btn-outline-primary d-flex align-items-center gap-2"
    @click="export_to_excel(selected_aif)"
    :disabled="isLoading"
>
    <template v-if="!isLoading">
        <i class="bi bi-download"></i>
        <span>Download</span>
    </template>

    <template v-else>
        <span class="spinner-border spinner-border-sm" role="status"></span>
        <span class="small">[[ downloadStep ]]</span>
    </template>
</button>


getCurrentDateTimeForFile() {
  const d = new Date();

  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const min = String(d.getMinutes()).padStart(2, "0");

  return `${yyyy}${mm}${dd}_${hh}${min}`;
}


const fileDate = this.getCurrentDateTimeForFile();

writeFile(
  wb,
  `WebADI_AIF_${aif.aif_id}_Header_Set_${fileDate}.xlsx`
);

const fileDate = this.getCurrentDateTimeForFile();

writeFile(
  wb,
  `WebADI_AIF_${aif.aif_id}_Line_Set_${fileDate}.xlsx`
);



<template v-else-if="key === 'aif_cancel_numbers'">
    [[ (selected_aif[key] || '').split(';').join(', ') ]]
</template>


async export_to_excel(aif) {
  this.isLoading = true;
  this.downloadStep = "Preparing‚Ä¶";

  const hasCustomers = (aif.aif_customer_lines || []).length > 0;

  this.downloadStep = "Generating Header file‚Ä¶";
  await this.generateWebEDIHeaderFile(aif);

  if (hasCustomers) {
    this.downloadStep = "Generating Line file‚Ä¶";
    await this.generateWebEDILineFile(aif);
  }

  this.downloadStep = "Finalizing‚Ä¶";

  this.isLoading = false;
  this.downloadStep = "";
}



<template v-else-if="key === 'aif_to_be_cancelled'">
        <ul class="mb-0 ps-3">
            <li
                v-for="(aif, index) in selected_aif[key]?.split(';')"
                :key="index"
            >
                [[ aif ]]
            </li>
        </ul>
    </template>

async buildWebEDIHeaderRows({
  sourceAIF,        // cancelled AIF (for cancel) OR current AIF
  effectiveAIF,     // ALWAYS current AIF (for cancel)
  trxType           // "UPDATE" | "INSERT"
}) {
  if (!sourceAIF?.aif_lines?.length) return;

  // ‚úÖ OpUnit comes from the source AIF (cancelled or new)
  const opUnit = await this.getOperationUnitByNSO(sourceAIF.nso);

  const hasCustomers =
    Array.isArray(sourceAIF.aif_customer_lines) &&
    sourceAIF.aif_customer_lines.length > 0;

  const startDate = this.formatExcelDates(effectiveAIF.start_date);
  const endDate =
    trxType === "UPDATE"
      ? this.formatExcelDates(effectiveAIF.start_date) // cancel end
      : this.formatExcelDates(effectiveAIF.end_date);

  // =========================
  // NO CUSTOMER
  // =========================
  if (!hasCustomers) {
    sourceAIF.aif_lines.forEach(line => {
      this.ws_data.push([
        opUnit,
        trxType,
        this.buildModifierLineNo(line, effectiveAIF),
        "LINE",
        "Discount",
        startDate,
        endDate,
        "Y",
        "N",
        "List Line Adjustment",
        "Level 4 Incompatibility",
        1,
        "First Layer",
        line.mercury_code,
        100,
        "LOCAL",
        "",
        "New Price",
        Number(line.promotional_elp) || 0,
        "N"
      ]);
    });
    return;
  }

  // =========================
  // WITH CUSTOMER
  // =========================
  sourceAIF.aif_customer_lines.forEach(customer => {
    const customerId = customer.oracle_cust_number;

    sourceAIF.aif_lines.forEach(line => {
      this.ws_data.push([
        opUnit,
        trxType,
        this.buildModifierLineNo(line, effectiveAIF, customerId),
        "LINE",
        "Discount",
        startDate,
        endDate,
        "Y",
        "N",
        "List Line Adjustment",
        "Level 4 Incompatibility",
        1,
        "First Layer",
        line.mercury_code,
        100,
        "LOCAL",
        "",
        "New Price",
        Number(line.promotional_elp) || 0,
        "N"
      ]);
    });
  });
}






async load_aifs_for_cancellation(aifIds = []) {
  const aifs_cancellation_list = [];

  for (const aifId of aifIds) {
    let aifData = null;

    // 1Ô∏è‚É£ Load AIF (base object)
    await fetch(api_endpoints.aif + aifId + "/")
      .then(res => res.json())
      .then(data => {
        aifData = data;
      });

    if (!aifData) continue;

    // 2Ô∏è‚É£ Attach AIF lines (same key as current AIF)
    await fetch(api_endpoints.aif_lines + "?aif=" + aifId)
      .then(res => res.json())
      .then(data => {
        aifData.aif_lines = data;
      });

    // 3Ô∏è‚É£ Attach customer lines (same key as current AIF)
    await fetch(api_endpoints.aif_customer_line + "?aif=" + aifId)
      .then(res => res.json())
      .then(data => {
        aifData.aif_customer_lines = data;
      });

    // ‚úÖ Push in SAME SHAPE as selected_aif
    aifs_cancellation_list.push(aifData);
  }

  return aifs_cancellation_list;
}





async buildWebEDIHeaderRows({
  sourceAIF,        // where lines/customers come from
  effectiveAIF,     // whose dates & aif_id apply
  trxType           // "UPDATE" | "INSERT"
}) {
  if (!sourceAIF?.aif_lines?.length) return;

  // üîë OpUnit resolved from EFFECTIVE AIF
  const opUnit = await this.getOperationUnitByNSO(effectiveAIF.nso);

  const customers =
    sourceAIF.aif_customer_lines?.length
      ? sourceAIF.aif_customer_lines
      : [null];

  customers.forEach(customer => {
    const customerId = customer?.oracle_cust_number || null;

    sourceAIF.aif_lines.forEach(line => {
      this.ws_data.push([
        opUnit,
        trxType,
        this.buildModifierLineNo(line, effectiveAIF, customerId),
        "LINE",
        "Discount",
        this.formatExcelDates(effectiveAIF.start_date),
        this.formatExcelDates(
          trxType === "UPDATE"
            ? effectiveAIF.start_date
            : effectiveAIF.end_date
        ),
        "Y",
        "N",
        "List Line Adjustment",
        "Level 4 Incompatibility",
        1,
        "First Layer",
        line.mercury_code,
        100,
        "LOCAL",
        "",
        "New Price",
        Number(line.promotional_elp) || 0,
        "N"
      ]);
    });
  });
}










async load_aifs_for_cancellation(aifIds = []) {
    this.aifs_for_cancellation = [];

    for (const aifId of aifIds) {
        const aifObj = {};

        // 1Ô∏è‚É£ AIF header
        await fetch(api_endpoints.aif + aifId + "/")
            .then(response => response.json())
            .then(data => {
                aifObj.aif = data;
            });

        // 2Ô∏è‚É£ AIF lines
        await fetch(api_endpoints.aif_lines + "?aif=" + aifId)
            .then(response => response.json())
            .then(data => {
                aifObj.aif_lines = data;
            });

        // 3Ô∏è‚É£ AIF customer lines
        await fetch(api_endpoints.aif_customer_line + "?aif=" + aifId)
            .then(response => response.json())
            .then(data => {
                aifObj.aif_customer_lines = data;
            });

        // 4Ô∏è‚É£ Store fully prepared AIF
        this.aifs_for_cancellation.push(aifObj);
    }
}
